<!-- _includes/gbgvarvet_interactive.html -->

<style>
    .controls {
        margin-bottom: 20px;
        padding: 15px;
        border: 1px solid #eee;
        border-radius: 5px;
        background-color: #f9f9f9;
    }
    .controls label {
        margin-right: 10px;
    }
    .controls input[type="text"], .controls select {
        padding: 8px;
        margin-right: 15px;
        border: 1px solid #ccc;
        border-radius: 4px;
    }
    #plotContainer {
        width: 100%;
        max-width: 800px; /* Adjust as needed */
        height: 500px; /* Adjust as needed */
        margin: 0 auto;
        border: 1px solid #ddd; /* Added for visibility during debugging */
    }
    #percentileResult {
        margin-top: 15px;
        font-weight: bold;
        font-size: 1.1em;
        text-align: center;
    }
    .error-message {
        color: red;
        font-style: italic;
    }
</style>

<div class="controls">
    <label for="userTime">Your Finish Time (HH:MM:SS):</label>
    <input type="text" id="userTime" placeholder="e.g., 01:45:30">

    <label for="genderFilter">Filter by Gender:</label>
    <select id="genderFilter">
        <option value="All">All Runners</option>
        <option value="Men">Men</option>
        <option value="Women">Women</option>
    </select>

    <p id="inputError" class="error-message" style="display:none;"></p>
</div>

<div id="plotContainer">
    <p>Loading chart...</p>
</div>
<div id="percentileResult"></div>

<!-- Plotly.js CDN - Using latest stable version (e.g., 2.32.0) -->
<script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>

<script>
    // Wrap the entire script in a self-executing anonymous function
    // to create a local scope and avoid polluting the global scope.
    // Also helps ensure code runs after HTML elements are potentially available.
    (function() {
        console.log("Main script wrapper executing."); // Log: Script execution starts

        let allData = [];
        const plotDiv = document.getElementById('plotContainer');
        const userTimeInput = document.getElementById('userTime');
        const genderFilterSelect = document.getElementById('genderFilter');
        const percentileResultDiv = document.getElementById('percentileResult');
        const inputErrorDiv = document.getElementById('inputError');

        // Basic check if essential elements are found
        if (!plotDiv || !userTimeInput || !genderFilterSelect || !percentileResultDiv || !inputErrorDiv) {
            console.error("One or more essential HTML elements not found. Check IDs. plotDiv:", plotDiv, "userTimeInput:", userTimeInput, "genderFilterSelect:", genderFilterSelect);
            if (plotDiv) plotDiv.innerHTML = "<p style='color:red;'>Error: Essential page elements missing for the chart. Check console.</p>";
            return; // Stop script if elements are missing
        }
        console.log("Essential HTML elements for chart interaction found."); // Log: Elements found

        // Function to parse HH:MM:SS to total minutes
        function parseTimeToMinutes(timeStr) {
            if (!timeStr || !/^\d{2}:\d{2}:\d{2}$/.test(timeStr)) {
                return null; // Invalid format
            }
            const parts = timeStr.split(':').map(Number);
            if (parts.length === 3 && parts.every(p => !isNaN(p) && p >= 0) && parts[1] < 60 && parts[2] < 60) {
                return parts[0] * 60 + parts[1] + parts[2] / 60;
            }
            return null; // Invalid values
        }

        // Function to fetch data and initialize
        async function initialize() {
            console.log("Initializing interactive chart..."); // Log: initialize() called
            try {
                // IMPORTANT: Ensure '{{ site.baseurl | relative_url }}' resolves correctly for your GH Pages setup.
                // If your site is at username.github.io (no repo name in path), site.baseurl is "" or "/".
                // If site is username.github.io/repo-name/, site.baseurl is "/repo-name".
                const dataUrl = `{{ site.baseurl | relative_url }}/assets/data/goteborgsvarvet_2025_results.json`;
                console.log("Attempting to fetch data from:", dataUrl); // Log: Data URL
                const response = await fetch(dataUrl);
                console.log("Fetch response status:", response.status, "ok:", response.ok); // Log: Fetch status

                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status} while fetching ${dataUrl}. Check if the file exists and the path is correct (view Network tab in dev tools).`);
                }
                
                const rawData = await response.text();
                try {
                    allData = JSON.parse(rawData);
                } catch (jsonError) {
                    console.error("Error parsing JSON data:", jsonError);
                    console.error("Raw data received (first 500 chars):", rawData.substring(0, 500) + "...");
                    throw new Error(`Failed to parse JSON data. Is the file content valid JSON? Details: ${jsonError.message}`);
                }
                
                console.log("Data fetched and parsed. Number of records:", allData.length); // Log: Data count
                if (allData.length > 0) {
                    console.log("First data record example:", allData[0]); // Log: First record
                } else {
                    console.warn("JSON data loaded, but it's an empty array.");
                    plotDiv.innerHTML = '<p style="color:orange;">Race data loaded, but it appears to be empty.</p>';
                    return; // Stop if no data
                }

                let invalidMinutesCount = 0;
                allData.forEach((d, index) => {
                    const originalMinutes = d.Finish_Minutes;
                    d.Finish_Minutes = parseFloat(d.Finish_Minutes);
                    if (isNaN(d.Finish_Minutes)) {
                        console.warn(`Record ${index} has invalid Finish_Minutes (original: "${originalMinutes}", parsed: NaN):`, d);
                        invalidMinutesCount++;
                    }
                });
                if (invalidMinutesCount > 0) {
                    console.warn(`${invalidMinutesCount} records had invalid Finish_Minutes values that were converted to NaN.`);
                }
                
                plotDiv.innerHTML = ''; // Clear "Loading chart..."
                console.log("Cleared 'Loading chart...' message from plotDiv.");

                updatePlot(); // Initial plot
                console.log("Initial plot generation called.");

                userTimeInput.addEventListener('input', () => {
                    console.log("User time input event. Value:", userTimeInput.value);
                    updatePlot();
                });
                genderFilterSelect.addEventListener('change', () => {
                    console.log("Gender filter change event. Value:", genderFilterSelect.value);
                    updatePlot();
                });
                console.log("Event listeners added.");

            } catch (error) {
                console.error("Error during initialization:", error);
                plotDiv.innerHTML = `<p style="color:red; font-weight:bold;">Error loading race data:</p><p style="color:red;">${error.message}</p><p>Please check the browser's developer console (F12) for more details (especially the Network tab for the JSON file request).</p>`;
            }
        }

        // Function to update the plot and percentile
        function updatePlot() {
            console.log("updatePlot function called."); // Log: updatePlot() called
            if (!allData || typeof allData.filter !== 'function') { // Check if allData is an array
                console.warn("updatePlot called, but allData is not an array or not initialized properly. allData:", allData);
                if (plotDiv.innerHTML.includes("Loading chart...") || plotDiv.innerHTML === "") {
                    plotDiv.innerHTML = '<p style="color:orange;">Data not available for plotting. Check initialization logs.</p>';
                }
                return;
            }
            if (allData.length === 0 && !plotDiv.innerHTML.includes("empty")) { // If initialized but data array was empty
                 console.warn("updatePlot called, but allData is an empty array.");
                 if (!plotDiv.innerHTML.includes("Race data loaded, but it appears to be empty.")) {
                    plotDiv.innerHTML = '<p style="color:orange;">No data to display in the chart.</p>';
                 }
                 return;
            }


            const selectedGender = genderFilterSelect.value;
            console.log("Selected gender for plot:", selectedGender);
            let filteredData = allData;

            if (selectedGender !== "All") {
                filteredData = allData.filter(d => d && d["Gender Category"] === selectedGender);
            }
            console.log("Number of records after gender filtering:", filteredData.length);

            if (filteredData.length === 0) {
                plotDiv.innerHTML = `<p>No data available for the selected filter: "${selectedGender}".</p>`;
                percentileResultDiv.textContent = '';
                console.log("No data for the current filter, plot area updated.");
                return;
            }

            const finishTimesMinutes = filteredData.map(d => d.Finish_Minutes).filter(time => typeof time === 'number' && !isNaN(time));
            console.log(`Plotting ${finishTimesMinutes.length} valid finish times (minutes). First 5:`, finishTimesMinutes.slice(0, 5));

            if (finishTimesMinutes.length === 0) {
                console.warn("No valid numeric finish times to plot after filtering NaNs for gender:", selectedGender);
                plotDiv.innerHTML = `<p>No valid time data to plot for "${selectedGender}". Please check data quality (e.g., 'Finish_Minutes' values).</p>`;
                percentileResultDiv.textContent = '';
                return;
            }

            const userTimeStr = userTimeInput.value;
            const userTimeMinutes = parseTimeToMinutes(userTimeStr);
            console.log("User time input string:", userTimeStr, "| Parsed minutes:", userTimeMinutes);

            let percentileText = "";
            const shapes = [];

            inputErrorDiv.style.display = 'none';
            inputErrorDiv.textContent = '';

            if (userTimeStr && userTimeMinutes === null) {
                inputErrorDiv.textContent = "Invalid time format. Please use HH:MM:SS (e.g., 01:45:30).";
                inputErrorDiv.style.display = 'block';
                console.log("User time input is present but format is invalid.");
            }

            if (userTimeMinutes !== null) {
                shapes.push({
                    type: 'line',
                    x0: userTimeMinutes,
                    y0: 0,
                    x1: userTimeMinutes,
                    y1: 1,
                    yref: 'paper',
                    line: { color: 'red', width: 2, dash: 'dashdot' }
                });
                console.log("Added vertical line shape for user time at:", userTimeMinutes);

                const runnersSlowerThanUser = filteredData.filter(d => typeof d.Finish_Minutes === 'number' && !isNaN(d.Finish_Minutes) && d.Finish_Minutes > userTimeMinutes).length;
                const totalComparableRunners = filteredData.filter(d => typeof d.Finish_Minutes === 'number' && !isNaN(d.Finish_Minutes)).length; // Count only those with valid times

                if (totalComparableRunners > 0) {
                    const percentileBetterThan = (runnersSlowerThanUser / totalComparableRunners) * 100;
                    percentileText = `Your time of ${userTimeStr} is faster than <strong>${percentileBetterThan.toFixed(1)}%</strong> of runners in the "${selectedGender}" category.`;
                    if (percentileBetterThan.toFixed(1) === '100.0') {
                        percentileText = `Your time of ${userTimeStr} is faster than all other recorded times in the "${selectedGender}" category!`;
                    } else if (percentileBetterThan.toFixed(1) === '0.0') {
                        const maxTimeInGroup = Math.max(...finishTimesMinutes.filter(t => !isNaN(t))); // Ensure no NaNs here
                        if (userTimeMinutes >= maxTimeInGroup) {
                            percentileText = `Your time of ${userTimeStr} appears to be the slowest recorded in the "${selectedGender}" category.`;
                        } else {
                            percentileText = `Your time of ${userTimeStr} is among the slower times in the "${selectedGender}" category.`;
                        }
                    }
                    console.log("Calculated percentile text:", percentileText);
                } else {
                     percentileText = "Cannot calculate percentile: No comparable runner data for this filter.";
                }
            }
            percentileResultDiv.innerHTML = percentileText;

            const trace = {
                x: finishTimesMinutes,
                type: 'histogram',
                marker: { color: 'rgb(100,150,200)' },
                name: 'Finish Times'
            };

            const layout = {
                title: `Göteborgsvarvet 2025: Finish Time Distribution (${selectedGender})`,
                xaxis: { title: 'Finish Time (minutes)' },
                yaxis: { title: 'Number of Runners' },
                shapes: shapes,
                bargap: 0.05
            };

            console.log("Trace data for Plotly (first 10):", JSON.stringify(trace.x.slice(0,10)) + "...");
            console.log("Layout for Plotly:", layout);

            try {
                if (typeof Plotly === 'undefined') {
                    console.error("Plotly library is not loaded!");
                    plotDiv.innerHTML = "<p style='color:red;'>Plotly library not loaded. Chart cannot be displayed.</p>";
                    return;
                }
                Plotly.react(plotDiv, [trace], layout);
                console.log("Plotly.react called, chart should be updated/rendered.");
            } catch (plotlyError) {
                console.error("Error calling Plotly.react:", plotlyError);
                plotDiv.innerHTML = `<p style="color:red; font-weight:bold;">Chart Rendering Error:</p><p style="color:red;">${plotlyError.message}</p><p>Check console for details.</p>`;
            }
        }

        // DOMContentLoaded listener
        console.log("Script parsed. Setting up DOMContentLoaded listener.");
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOMContentLoaded event fired. Attempting to start initialization.");
            try {
                if (typeof initialize === 'function') {
                    initialize();
                    console.log("Call to initialize() completed without throwing an immediate error from the listener.");
                } else {
                    console.error("initialize function is not defined when DOMContentLoaded fired!");
                    if (plotDiv) plotDiv.innerHTML = "<p style='color:red;'>Critical error: Initialization function missing. Check script.</p>";
                }
            } catch (e) {
                console.error("Error thrown DIRECTLY from initialize() call within DOMContentLoaded:", e);
                if (plotDiv) plotDiv.innerHTML = `<p style="color:red; font-weight:bold;">Critical error during initialize() call:</p><p style="color:red;">${e.message}</p><p>Check console.</p>`;
            }
        });
        console.log("DOMContentLoaded listener has been set.");

    })(); // End of self-executing anonymous function
</script>
