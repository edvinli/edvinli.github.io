<!-- _includes/gbgvarvet_interactive.html -->

<style>
    .controls {
        margin-bottom: 20px;
        padding: 15px;
        border: 1px solid #eee;
        border-radius: 5px;
        background-color: #f9f9f9;
    }
    .controls label {
        margin-right: 10px;
    }
    .controls input[type="text"], .controls select {
        padding: 8px;
        margin-right: 15px;
        border: 1px solid #ccc;
        border-radius: 4px;
    }
    #plotContainer {
        width: 100%;
        max-width: 800px; /* Adjust as needed */
        height: 500px; /* Adjust as needed */
        margin: 0 auto;
    }
    #percentileResult {
        margin-top: 15px;
        font-weight: bold;
        font-size: 1.1em;
        text-align: center;
    }
    .error-message {
        color: red;
        font-style: italic;
    }
</style>

<div class="controls">
    <label for="userTime">Your Finish Time (HH:MM:SS):</label>
    <input type="text" id="userTime" placeholder="e.g., 01:45:30">

    <label for="genderFilter">Filter by Gender:</label>
    <select id="genderFilter">
        <option value="All">All Runners</option>
        <option value="Men">Men</option>
        <option value="Women">Women</option>
    </select>

    <p id="inputError" class="error-message" style="display:none;"></p>
</div>

<div id="plotContainer">
    <p>Loading chart...</p>
</div>
<div id="percentileResult"></div>

<!-- Plotly.js CDN -->
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>

<script>
    let allData = [];
    const plotDiv = document.getElementById('plotContainer');
    const userTimeInput = document.getElementById('userTime');
    const genderFilterSelect = document.getElementById('genderFilter');
    const percentileResultDiv = document.getElementById('percentileResult');
    const inputErrorDiv = document.getElementById('inputError');

    // Function to parse HH:MM:SS to total minutes
    function parseTimeToMinutes(timeStr) {
        if (!timeStr || !/^\d{2}:\d{2}:\d{2}$/.test(timeStr)) {
            return null; // Invalid format
        }
        const parts = timeStr.split(':').map(Number);
        if (parts.length === 3 && parts.every(p => !isNaN(p) && p >= 0) && parts[1] < 60 && parts[2] < 60) {
            return parts[0] * 60 + parts[1] + parts[2] / 60;
        }
        return null; // Invalid values
    }

    // Function to fetch data and initialize
    async function initialize() {
        try {
            const response = await fetch('{{ site.baseurl }}/assets/data/goteborgsvarvet_2025_results.json');
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            allData = await response.json();
            // Ensure Finish_Minutes is a number
            allData.forEach(d => d.Finish_Minutes = parseFloat(d.Finish_Minutes));
            
            plotDiv.innerHTML = ''; // Clear "Loading chart..."
            updatePlot(); // Initial plot
        } catch (error) {
            console.error("Error loading or parsing data:", error);
            plotDiv.innerHTML = `<p style="color:red;">Error loading race data: ${error.message}. Please check the console for more details.</p>`;
        }

        userTimeInput.addEventListener('input', () => {
            // Basic validation for live feedback, more robust in parseTimeToMinutes
            if (userTimeInput.value && !/^\d{0,2}:?\d{0,2}:?\d{0,2}$/.test(userTimeInput.value)) {
                 // allow partial input like 01: or 01:4
            }
            updatePlot();
        });
        genderFilterSelect.addEventListener('change', updatePlot);
    }

    // Function to update the plot and percentile
    function updatePlot() {
        if (allData.length === 0) return; // Data not loaded yet

        const selectedGender = genderFilterSelect.value;
        let filteredData = allData;

        if (selectedGender !== "All") {
            filteredData = allData.filter(d => d["Gender Category"] === selectedGender);
        }

        if (filteredData.length === 0) {
            plotDiv.innerHTML = `<p>No data available for the selected filter: ${selectedGender}.</p>`;
            percentileResultDiv.textContent = '';
            return;
        }

        const finishTimesMinutes = filteredData.map(d => d.Finish_Minutes);

        const userTimeStr = userTimeInput.value;
        const userTimeMinutes = parseTimeToMinutes(userTimeStr);

        let percentileText = "";
        const shapes = [];

        inputErrorDiv.style.display = 'none';
        inputErrorDiv.textContent = '';

        if (userTimeStr && userTimeMinutes === null) {
            inputErrorDiv.textContent = "Invalid time format. Please use HH:MM:SS (e.g., 01:45:30).";
            inputErrorDiv.style.display = 'block';
        }

        if (userTimeMinutes !== null) {
            shapes.push({
                type: 'line',
                x0: userTimeMinutes,
                y0: 0,
                x1: userTimeMinutes,
                y1: 1,
                yref: 'paper', // y-coordinate is relative to the plot area
                line: {
                    color: 'red',
                    width: 2,
                    dash: 'dashdot'
                }
            });

            // Calculate percentile: "You finished ahead of X% of runners in this category."
            // This means we count runners Slower than or Equal to the user's time.
            // Or, more commonly, "You are faster than X% of people".
            // Let's use: You are in the top (100-P)%, or P% of people are slower than you.
            // Count runners whose Finish_Minutes is GREATER than userTimeMinutes
            const slowerRunners = filteredData.filter(d => d.Finish_Minutes > userTimeMinutes).length;
            const percentile = (slowerRunners / filteredData.length) * 100;
            
            // Alternative: Rank (1st is best)
            // const sortedTimes = [...new Set(finishTimesMinutes)].sort((a, b) => a - b);
            // let rank = sortedTimes.findIndex(t => t >= userTimeMinutes);
            // if (rank === -1) rank = sortedTimes.length; // Slower than everyone
            // else rank +=1; // 1-based index
            // const rankPercentile = ((filteredData.length - rank + 1) / filteredData.length) * 100;


            if (filteredData.length > 0) {
                percentileText = `Your time of ${userTimeStr} places you ahead of <strong>${percentile.toFixed(1)}%</strong> of runners in the "${selectedGender}" category.`;
                 if (percentile.toFixed(1) === '100.0') {
                    percentileText = `Your time of ${userTimeStr} is faster than all other recorded times in the "${selectedGender}" category!`;
                } else if (percentile.toFixed(1) === '0.0' && filteredData.some(d => d.Finish_Minutes < userTimeMinutes)) {
                     percentileText = `Your time of ${userTimeStr} is among the slower times in the "${selectedGender}" category.`;
                } else if (percentile.toFixed(1) === '0.0') {
                     percentileText = `Your time of ${userTimeStr} appears to be the slowest recorded in the "${selectedGender}" category.`;
                }

            } else {
                percentileText = "Cannot calculate percentile with no data for this filter.";
            }
        }
        percentileResultDiv.innerHTML = percentileText;


        const trace = {
            x: finishTimesMinutes,
            type: 'histogram',
            autobinx: false,
            xbins: {
                // size: 5 // Bin size in minutes, e.g., every 5 minutes
                // Or let Plotly decide:
                // start: Math.min(...finishTimesMinutes),
                // end: Math.max(...finishTimesMinutes)
            },
            marker: {
                color: 'rgb(100,150,200)',
            },
            name: 'Finish Times'
        };

        const layout = {
            title: `GÃ¶teborgsvarvet 2025: Finish Time Distribution (${selectedGender})`,
            xaxis: {
                title: 'Finish Time (minutes)',
                // tickformat: ".0f" // if you want integer minutes on ticks
            },
            yaxis: {
                title: 'Number of Runners'
            },
            shapes: shapes,
            bargap: 0.05 // Gap between bars
        };

        Plotly.react(plotDiv, [trace], layout); // Use react for efficient updates
    }

    // Initialize when the DOM is ready
    document.addEventListener('DOMContentLoaded', initialize);

</script>
